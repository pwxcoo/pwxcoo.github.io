<!DOCTYPE html>
<html lang=en>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <!-- fix Sina weibo image host temporarily -->
    <meta name="referrer" content="no-referrer" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="排序算法是最基本最入门的东西了，回顾排序算法的时候好像回到了大一。。  冒泡遍历两两交换。两层遍历。 选择排序我感觉最接近人类思维的排序了，我最早就是用这个写的排序。就是找个最小的放到前面，然后剩下的里面再找个最小的。两层遍历。 插入排序两层遍历。分成无序的一堆，有序的一堆，每次无序里面拿一个放到有序里面合适的位置就好了。 希尔排序感觉出场率很低。用一个增量 d 排序，每次 x 和 x + d 比">
<meta property="og:type" content="website">
<meta property="og:title" content="10种排序算法">
<meta property="og:url" content="https://blog.pwxcoo.com/archive/10%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html">
<meta property="og:site_name" content="PWXCOO">
<meta property="og:description" content="排序算法是最基本最入门的东西了，回顾排序算法的时候好像回到了大一。。  冒泡遍历两两交换。两层遍历。 选择排序我感觉最接近人类思维的排序了，我最早就是用这个写的排序。就是找个最小的放到前面，然后剩下的里面再找个最小的。两层遍历。 插入排序两层遍历。分成无序的一堆，有序的一堆，每次无序里面拿一个放到有序里面合适的位置就好了。 希尔排序感觉出场率很低。用一个增量 d 排序，每次 x 和 x + d 比">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog.pwxcoo.com/image/排序算法.png">
<meta property="article:published_time" content="2018-03-01T09:24:41.000Z">
<meta property="article:modified_time" content="2022-03-24T05:48:48.876Z">
<meta property="article:author" content="pwxcoo">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.pwxcoo.com/image/排序算法.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>10种排序算法</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="PWXCOO" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body class="max-width mx-auto px3 ">
    
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="content index py4">
        
          <header id="header">
  <a href="/">
  
    
      <div id="logo" style="background-image: url(/images/logo.png);"></div>
    
  
    <div id="title">
      <h1>PWXCOO</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
       
        <li><a href="/">Home</a></li>
       
        <li><a href="/archives/">Archives</a></li>
       
        <li><a href="/toc/">Toc</a></li>
       
        <li><a href="/about/">About</a></li>
      
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <p>排序算法是最基本最入门的东西了，回顾排序算法的时候好像回到了大一。。</p>
<p><img src="/image/排序算法.png" alt="排序算法.png"></p>
<h2 id="冒泡遍历"><a href="#冒泡遍历" class="headerlink" title="冒泡遍历"></a>冒泡遍历</h2><p>两两交换。两层遍历。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>我感觉最接近人类思维的排序了，我最早就是用这个写的排序。就是找个最小的放到前面，然后剩下的里面再找个最小的。两层遍历。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>两层遍历。分成无序的一堆，有序的一堆，每次无序里面拿一个放到有序里面合适的位置就好了。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>感觉出场率很低。用一个增量 d 排序，每次 x 和 x + d 比较。然后 d 再除以 2 ，直到 d 变成 0 结束。我看网上一般增量取的都是 5 。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治。两个排好序的数组合成成一个数组。时间复杂度 O(nlogn) ,而且还稳定。可惜需要 O(n) 额外的空间。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>简单来说就是选一个元素，比这个小的放到左边，比这个大的放到右边，然后再对左边和右边递归。平均时间复杂度 O(nlogn) 。最差的时候就是每次选到本来就是最小的，或者最大的，就会退化成 O(n^2) 。</p>
<p>随便找了个算法题，写了个快排。 hdu1040 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1005</span>];</span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                numbers[i] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QuickSort(numbers, <span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.print(numbers[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot; %d&quot;</span>, numbers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] numbers, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> numbers[left];</span><br><span class="line">        numbers[left] = numbers[right];</span><br><span class="line">        numbers[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] numbers, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextLeft</span> <span class="operator">=</span> left, nextRight = right;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; numbers[right] &gt;= numbers[left]) right--;</span><br><span class="line">            swap(numbers, left, right);</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; numbers[left] &lt;= numbers[right]) left++;</span><br><span class="line">            swap(numbers, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        QuickSort(numbers, nextLeft, left - <span class="number">1</span>);</span><br><span class="line">        QuickSort(numbers, left + <span class="number">1</span>, nextRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>一个完全二叉树。因为完全二叉树直接用数组就可以模拟。根结点放在 1 下标，方便计算。</p>
<p>最后一个元素下标就是 n 。初始化的时候，调整 1 ~ n / 2 的结点。取出元素的时候，拿出根结点，然后把 n 下标的元素放到 根结点，然后调整根结点，维护这个堆。</p>
<p>同样也用 hdu1040 写了个堆排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] heap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1005</span>];</span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                heap[i] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HeapSort(heap, num);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print(heap[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot; %d&quot;</span>, heap[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap[n];</span><br><span class="line">        heap[n] = heap[m];</span><br><span class="line">        heap[m] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> now, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * now &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (<span class="number">2</span> * now + <span class="number">1</span> &gt; n || heap[<span class="number">2</span> * now] &gt; heap[<span class="number">2</span> * now + <span class="number">1</span>])</span><br><span class="line">                            ? <span class="number">2</span> * now : <span class="number">2</span> * now + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(heap[next] &gt; heap[now])</span><br><span class="line">                swap(heap, now, next);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            now = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            adjustHeap(heap, i, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap, <span class="number">1</span>, i);</span><br><span class="line">            adjustHeap(heap, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>要求输入的数范围确定，然后用一个数组来模拟计数每个元素的个数。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>计数排序的升级版。比如 1 来放 0 - 9 的数，放到里面后对每个非空桶再排序，减少了一些空间的浪费。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>得到最大数的位数。先对个位排序，然后十位数排序，直到超过最大位。</p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2022 pwxcoo
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/toc/">Toc</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- mathjax -->
<script src="https://cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=default">
  MathJax.Hub.Config({
   tex2jax: {
   inlineMath: [['$','$'],["\\(","\\)"]],
   displayMath: [['\\[','\\]'], ['$$','$$']],
   },
});
</script>
<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-123052529-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'pwxcoo';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


